{"ast":null,"code":"// This is a patch for mozilla/source-map#349 -\n// internally, it uses the existence of the `fetch` global to toggle browser behaviours.\n// That check, however, will break when `fetch` polyfills are used for SSR setups.\n// We \"reset\" the polyfill here to ensure it won't interfere with source-map generation.\nconst originalFetch = global.fetch;\ndelete global.fetch;\n\nconst {\n  SourceMapConsumer,\n  SourceMapGenerator,\n  SourceNode\n} = require('source-map');\n\nconst {\n  Template\n} = require('webpack');\n/**\n * Generates an identity source map from a source file.\n * @param {string} source The content of the source file.\n * @param {string} resourcePath The name of the source file.\n * @returns {import('source-map').RawSourceMap} The identity source map.\n */\n\n\nfunction getIdentitySourceMap(source, resourcePath) {\n  const sourceMap = new SourceMapGenerator();\n  sourceMap.setSourceContent(resourcePath, source);\n  source.split('\\n').forEach((line, index) => {\n    sourceMap.addMapping({\n      source: resourcePath,\n      original: {\n        line: index + 1,\n        column: 0\n      },\n      generated: {\n        line: index + 1,\n        column: 0\n      }\n    });\n  });\n  return sourceMap.toJSON();\n}\n/**\n * Gets a runtime template from provided function.\n * @param {function(): void} fn A function containing the runtime template.\n * @returns {string} The \"sanitized\" runtime template.\n */\n\n\nfunction getTemplate(fn) {\n  return Template.getFunctionContent(fn).trim().replace(/^ {2}/gm, '');\n}\n\nconst RefreshSetupRuntime = getTemplate(require('./RefreshSetup.runtime')).replace('$RefreshRuntimePath$', require.resolve('react-refresh/runtime').replace(/\\\\/g, '/'));\nconst RefreshModuleRuntime = getTemplate(require('./RefreshModule.runtime'));\n/**\n * A simple Webpack loader to inject react-refresh HMR code into modules.\n *\n * [Reference for Loader API](https://webpack.js.org/api/loaders/)\n * @this {import('webpack').loader.LoaderContext}\n * @param {string} source The original module source code.\n * @param {import('source-map').RawSourceMap} [inputSourceMap] The source map of the module.\n * @param {*} [meta] The loader metadata passed in.\n * @returns {void}\n */\n\nfunction ReactRefreshLoader(source, inputSourceMap, meta) {\n  const callback = this.async();\n  /**\n   * @this {import('webpack').loader.LoaderContext}\n   * @param {string} source\n   * @param {import('source-map').RawSourceMap} [inputSourceMap]\n   * @returns {Promise<[string, import('source-map').RawSourceMap]>}\n   */\n\n  async function _loader(source, inputSourceMap) {\n    if (this.sourceMap) {\n      let originalSourceMap = inputSourceMap;\n\n      if (!originalSourceMap) {\n        originalSourceMap = getIdentitySourceMap(source, this.resourcePath);\n      }\n\n      const node = SourceNode.fromStringWithSourceMap(source, await new SourceMapConsumer(originalSourceMap));\n      node.prepend([RefreshSetupRuntime, '\\n\\n']);\n      node.add(['\\n\\n', RefreshModuleRuntime]);\n      const {\n        code,\n        map\n      } = node.toStringWithSourceMap();\n      return [code, map.toJSON()];\n    } else {\n      return [[RefreshSetupRuntime, source, RefreshModuleRuntime].join('\\n\\n'), inputSourceMap];\n    }\n  }\n\n  _loader.call(this, source, inputSourceMap).then(([code, map]) => {\n    callback(null, code, map, meta);\n  }, error => {\n    callback(error);\n  });\n}\n\nmodule.exports = ReactRefreshLoader; // Restore the original value of the `fetch` global, if it exists\n\nif (originalFetch) {\n  global.fetch = originalFetch;\n}","map":{"version":3,"sources":["E:/JCA/Projects/Project-5/Grade-A/Front-End/node_modules/@pmmmwh/react-refresh-webpack-plugin/loader/index.js"],"names":["originalFetch","global","fetch","SourceMapConsumer","SourceMapGenerator","SourceNode","require","Template","getIdentitySourceMap","source","resourcePath","sourceMap","setSourceContent","split","forEach","line","index","addMapping","original","column","generated","toJSON","getTemplate","fn","getFunctionContent","trim","replace","RefreshSetupRuntime","resolve","RefreshModuleRuntime","ReactRefreshLoader","inputSourceMap","meta","callback","async","_loader","originalSourceMap","node","fromStringWithSourceMap","prepend","add","code","map","toStringWithSourceMap","join","call","then","error","module","exports"],"mappings":"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","sourcesContent":["// This is a patch for mozilla/source-map#349 -\n// internally, it uses the existence of the `fetch` global to toggle browser behaviours.\n// That check, however, will break when `fetch` polyfills are used for SSR setups.\n// We \"reset\" the polyfill here to ensure it won't interfere with source-map generation.\nconst originalFetch = global.fetch;\ndelete global.fetch;\n\nconst { SourceMapConsumer, SourceMapGenerator, SourceNode } = require('source-map');\nconst { Template } = require('webpack');\n\n/**\n * Generates an identity source map from a source file.\n * @param {string} source The content of the source file.\n * @param {string} resourcePath The name of the source file.\n * @returns {import('source-map').RawSourceMap} The identity source map.\n */\nfunction getIdentitySourceMap(source, resourcePath) {\n  const sourceMap = new SourceMapGenerator();\n  sourceMap.setSourceContent(resourcePath, source);\n\n  source.split('\\n').forEach((line, index) => {\n    sourceMap.addMapping({\n      source: resourcePath,\n      original: {\n        line: index + 1,\n        column: 0,\n      },\n      generated: {\n        line: index + 1,\n        column: 0,\n      },\n    });\n  });\n\n  return sourceMap.toJSON();\n}\n\n/**\n * Gets a runtime template from provided function.\n * @param {function(): void} fn A function containing the runtime template.\n * @returns {string} The \"sanitized\" runtime template.\n */\nfunction getTemplate(fn) {\n  return Template.getFunctionContent(fn).trim().replace(/^ {2}/gm, '');\n}\n\nconst RefreshSetupRuntime = getTemplate(require('./RefreshSetup.runtime')).replace(\n  '$RefreshRuntimePath$',\n  require.resolve('react-refresh/runtime').replace(/\\\\/g, '/')\n);\nconst RefreshModuleRuntime = getTemplate(require('./RefreshModule.runtime'));\n\n/**\n * A simple Webpack loader to inject react-refresh HMR code into modules.\n *\n * [Reference for Loader API](https://webpack.js.org/api/loaders/)\n * @this {import('webpack').loader.LoaderContext}\n * @param {string} source The original module source code.\n * @param {import('source-map').RawSourceMap} [inputSourceMap] The source map of the module.\n * @param {*} [meta] The loader metadata passed in.\n * @returns {void}\n */\nfunction ReactRefreshLoader(source, inputSourceMap, meta) {\n  const callback = this.async();\n\n  /**\n   * @this {import('webpack').loader.LoaderContext}\n   * @param {string} source\n   * @param {import('source-map').RawSourceMap} [inputSourceMap]\n   * @returns {Promise<[string, import('source-map').RawSourceMap]>}\n   */\n  async function _loader(source, inputSourceMap) {\n    if (this.sourceMap) {\n      let originalSourceMap = inputSourceMap;\n      if (!originalSourceMap) {\n        originalSourceMap = getIdentitySourceMap(source, this.resourcePath);\n      }\n\n      const node = SourceNode.fromStringWithSourceMap(\n        source,\n        await new SourceMapConsumer(originalSourceMap)\n      );\n\n      node.prepend([RefreshSetupRuntime, '\\n\\n']);\n      node.add(['\\n\\n', RefreshModuleRuntime]);\n\n      const { code, map } = node.toStringWithSourceMap();\n      return [code, map.toJSON()];\n    } else {\n      return [[RefreshSetupRuntime, source, RefreshModuleRuntime].join('\\n\\n'), inputSourceMap];\n    }\n  }\n\n  _loader.call(this, source, inputSourceMap).then(\n    ([code, map]) => {\n      callback(null, code, map, meta);\n    },\n    (error) => {\n      callback(error);\n    }\n  );\n}\n\nmodule.exports = ReactRefreshLoader;\n\n// Restore the original value of the `fetch` global, if it exists\nif (originalFetch) {\n  global.fetch = originalFetch;\n}\n"]},"metadata":{},"sourceType":"script"}