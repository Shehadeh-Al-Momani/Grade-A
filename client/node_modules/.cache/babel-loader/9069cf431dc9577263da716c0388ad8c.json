{"ast":null,"code":"const querystring = require('querystring');\n\nconst createError = require('./createError');\n/** @typedef {string | string[] | import('webpack').Entry} StaticEntry */\n\n/** @typedef {StaticEntry | import('webpack').EntryFunc} WebpackEntry */\n\n/**\n * Checks if a Webpack entry string is related to socket integrations.\n * @param {string} entry A Webpack entry string.\n * @returns {boolean} Whether the entry is related to socket integrations.\n */\n\n\nfunction isSocketEntry(entry) {\n  /**\n   * Webpack entries related to socket integrations.\n   * They have to run before any code that sets up the error overlay.\n   * @type {string[]}\n   */\n  const socketEntries = ['webpack-dev-server/client', 'webpack-hot-middleware/client', 'webpack-plugin-serve/client', 'react-dev-utils/webpackHotDevClient'];\n  return socketEntries.some(socketEntry => entry.includes(socketEntry));\n}\n/**\n * Injects an entry to the bundle for react-refresh.\n * @param {WebpackEntry} [originalEntry] A Webpack entry object.\n * @param {import('../types').NormalizedPluginOptions} options Configuration options for this plugin.\n * @returns {WebpackEntry} An injected entry object.\n */\n\n\nfunction injectRefreshEntry(originalEntry, options) {\n  /** @type {Record<string, *>} */\n  let resourceQuery = {};\n\n  if (options.overlay) {\n    options.overlay.sockHost && (resourceQuery.sockHost = options.overlay.sockHost);\n    options.overlay.sockPath && (resourceQuery.sockPath = options.overlay.sockPath);\n    options.overlay.sockPort && (resourceQuery.sockPort = options.overlay.sockPort);\n  } // We don't need to URI encode the resourceQuery as it will be parsed by Webpack\n\n\n  const queryString = querystring.stringify(resourceQuery, undefined, undefined, {\n    /**\n     * @param {string} string\n     * @returns {string}\n     */\n    encodeURIComponent(string) {\n      return string;\n    }\n\n  });\n  const prependEntries = [// React-refresh runtime\n  require.resolve('../../client/ReactRefreshEntry')];\n  const overlayEntries = [// Legacy WDS SockJS integration\n  options.overlay && options.overlay.useLegacyWDSSockets && require.resolve('../../client/LegacyWDSSocketEntry'), // Error overlay runtime\n  options.overlay && options.overlay.entry && options.overlay.entry + (queryString && `?${queryString}`)].filter(Boolean); // Single string entry point\n\n  if (typeof originalEntry === 'string') {\n    if (isSocketEntry(originalEntry)) {\n      return [...prependEntries, originalEntry, ...overlayEntries];\n    }\n\n    return [...prependEntries, ...overlayEntries, originalEntry];\n  } // Single array entry point\n\n\n  if (Array.isArray(originalEntry)) {\n    const socketEntryIndex = originalEntry.findIndex(isSocketEntry);\n    let socketAndPrecedingEntries = [];\n\n    if (socketEntryIndex !== -1) {\n      socketAndPrecedingEntries = originalEntry.splice(0, socketEntryIndex + 1);\n    }\n\n    return [...prependEntries, ...socketAndPrecedingEntries, ...overlayEntries, ...originalEntry];\n  } // Multiple entry points\n\n\n  if (typeof originalEntry === 'object') {\n    return Object.entries(originalEntry).reduce((acc, [curKey, curEntry]) => ({ ...acc,\n      [curKey]: typeof curEntry === 'object' && curEntry.import ? { ...curEntry,\n        import: injectRefreshEntry(curEntry.import, options)\n      } : injectRefreshEntry(curEntry, options)\n    }), {});\n  } // Dynamic entry points\n\n\n  if (typeof originalEntry === 'function') {\n    return (...args) => Promise.resolve(originalEntry(...args)).then(resolvedEntry => injectRefreshEntry(resolvedEntry, options));\n  }\n\n  throw createError('Failed to parse the Webpack `entry` object!');\n}\n\nmodule.exports = injectRefreshEntry;","map":{"version":3,"sources":["E:/JCA/Projects/Project-5/Grade-A/Front-End/node_modules/@pmmmwh/react-refresh-webpack-plugin/lib/utils/injectRefreshEntry.js"],"names":["querystring","require","createError","isSocketEntry","entry","socketEntries","some","socketEntry","includes","injectRefreshEntry","originalEntry","options","resourceQuery","overlay","sockHost","sockPath","sockPort","queryString","stringify","undefined","encodeURIComponent","string","prependEntries","resolve","overlayEntries","useLegacyWDSSockets","filter","Boolean","Array","isArray","socketEntryIndex","findIndex","socketAndPrecedingEntries","splice","Object","entries","reduce","acc","curKey","curEntry","import","args","Promise","then","resolvedEntry","module","exports"],"mappings":"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","sourcesContent":["const querystring = require('querystring');\nconst createError = require('./createError');\n\n/** @typedef {string | string[] | import('webpack').Entry} StaticEntry */\n/** @typedef {StaticEntry | import('webpack').EntryFunc} WebpackEntry */\n\n/**\n * Checks if a Webpack entry string is related to socket integrations.\n * @param {string} entry A Webpack entry string.\n * @returns {boolean} Whether the entry is related to socket integrations.\n */\nfunction isSocketEntry(entry) {\n  /**\n   * Webpack entries related to socket integrations.\n   * They have to run before any code that sets up the error overlay.\n   * @type {string[]}\n   */\n  const socketEntries = [\n    'webpack-dev-server/client',\n    'webpack-hot-middleware/client',\n    'webpack-plugin-serve/client',\n    'react-dev-utils/webpackHotDevClient',\n  ];\n\n  return socketEntries.some((socketEntry) => entry.includes(socketEntry));\n}\n\n/**\n * Injects an entry to the bundle for react-refresh.\n * @param {WebpackEntry} [originalEntry] A Webpack entry object.\n * @param {import('../types').NormalizedPluginOptions} options Configuration options for this plugin.\n * @returns {WebpackEntry} An injected entry object.\n */\nfunction injectRefreshEntry(originalEntry, options) {\n  /** @type {Record<string, *>} */\n  let resourceQuery = {};\n  if (options.overlay) {\n    options.overlay.sockHost && (resourceQuery.sockHost = options.overlay.sockHost);\n    options.overlay.sockPath && (resourceQuery.sockPath = options.overlay.sockPath);\n    options.overlay.sockPort && (resourceQuery.sockPort = options.overlay.sockPort);\n  }\n\n  // We don't need to URI encode the resourceQuery as it will be parsed by Webpack\n  const queryString = querystring.stringify(resourceQuery, undefined, undefined, {\n    /**\n     * @param {string} string\n     * @returns {string}\n     */\n    encodeURIComponent(string) {\n      return string;\n    },\n  });\n\n  const prependEntries = [\n    // React-refresh runtime\n    require.resolve('../../client/ReactRefreshEntry'),\n  ];\n\n  const overlayEntries = [\n    // Legacy WDS SockJS integration\n    options.overlay &&\n      options.overlay.useLegacyWDSSockets &&\n      require.resolve('../../client/LegacyWDSSocketEntry'),\n    // Error overlay runtime\n    options.overlay &&\n      options.overlay.entry &&\n      options.overlay.entry + (queryString && `?${queryString}`),\n  ].filter(Boolean);\n\n  // Single string entry point\n  if (typeof originalEntry === 'string') {\n    if (isSocketEntry(originalEntry)) {\n      return [...prependEntries, originalEntry, ...overlayEntries];\n    }\n\n    return [...prependEntries, ...overlayEntries, originalEntry];\n  }\n  // Single array entry point\n  if (Array.isArray(originalEntry)) {\n    const socketEntryIndex = originalEntry.findIndex(isSocketEntry);\n\n    let socketAndPrecedingEntries = [];\n    if (socketEntryIndex !== -1) {\n      socketAndPrecedingEntries = originalEntry.splice(0, socketEntryIndex + 1);\n    }\n\n    return [...prependEntries, ...socketAndPrecedingEntries, ...overlayEntries, ...originalEntry];\n  }\n  // Multiple entry points\n  if (typeof originalEntry === 'object') {\n    return Object.entries(originalEntry).reduce(\n      (acc, [curKey, curEntry]) => ({\n        ...acc,\n        [curKey]:\n          typeof curEntry === 'object' && curEntry.import\n            ? {\n                ...curEntry,\n                import: injectRefreshEntry(curEntry.import, options),\n              }\n            : injectRefreshEntry(curEntry, options),\n      }),\n      {}\n    );\n  }\n  // Dynamic entry points\n  if (typeof originalEntry === 'function') {\n    return (...args) =>\n      Promise.resolve(originalEntry(...args)).then((resolvedEntry) =>\n        injectRefreshEntry(resolvedEntry, options)\n      );\n  }\n\n  throw createError('Failed to parse the Webpack `entry` object!');\n}\n\nmodule.exports = injectRefreshEntry;\n"]},"metadata":{},"sourceType":"script"}