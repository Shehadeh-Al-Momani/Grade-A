{"ast":null,"code":"const path = require('path');\n/**\n * @callback MatchObject\n * @param {string} [str]\n * @returns {boolean}\n */\n\n\nconst resolvedLoader = require.resolve('../../loader');\n/**\n * Injects refresh loader to all JavaScript-like and user-specified files.\n * @param {*} data Module factory creation data.\n * @param {MatchObject} matchObject A function to include/exclude files to be processed.\n * @returns {*} The injected module factory creation data.\n */\n\n\nfunction injectRefreshLoader(data, matchObject) {\n  if ( // Include and exclude user-specified files\n  matchObject(data.resource) && // Skip plugin's runtime utils to prevent self-referencing -\n  // this is useful when using the plugin as a direct dependency.\n  !data.resource.includes(path.join(__dirname, '../runtime/RefreshUtils')) && // Check to prevent double injection\n  !data.loaders.find(({\n    loader\n  }) => loader === resolvedLoader)) {\n    // As we inject runtime code for each module,\n    // it is important to run the injected loader after everything.\n    // This way we can ensure that all code-processing have been done,\n    // and we won't risk breaking tools like Flow or ESLint.\n    data.loaders.unshift({\n      loader: resolvedLoader,\n      options: undefined\n    });\n  }\n\n  return data;\n}\n\nmodule.exports = injectRefreshLoader;","map":{"version":3,"sources":["E:/JCA/Projects/Project-5/Grade-A/Front-End/node_modules/@pmmmwh/react-refresh-webpack-plugin/lib/utils/injectRefreshLoader.js"],"names":["path","require","resolvedLoader","resolve","injectRefreshLoader","data","matchObject","resource","includes","join","__dirname","loaders","find","loader","unshift","options","undefined","module","exports"],"mappings":"AAAA,MAAMA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;AAEA;AACA;AACA;AACA;AACA;;;AAEA,MAAMC,cAAc,GAAGD,OAAO,CAACE,OAAR,CAAgB,cAAhB,CAAvB;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,mBAAT,CAA6BC,IAA7B,EAAmCC,WAAnC,EAAgD;AAC9C,OACE;AACAA,EAAAA,WAAW,CAACD,IAAI,CAACE,QAAN,CAAX,IACA;AACA;AACA,GAACF,IAAI,CAACE,QAAL,CAAcC,QAAd,CAAuBR,IAAI,CAACS,IAAL,CAAUC,SAAV,EAAqB,yBAArB,CAAvB,CAHD,IAIA;AACA,GAACL,IAAI,CAACM,OAAL,CAAaC,IAAb,CAAkB,CAAC;AAAEC,IAAAA;AAAF,GAAD,KAAgBA,MAAM,KAAKX,cAA7C,CAPH,EAQE;AACA;AACA;AACA;AACA;AACAG,IAAAA,IAAI,CAACM,OAAL,CAAaG,OAAb,CAAqB;AACnBD,MAAAA,MAAM,EAAEX,cADW;AAEnBa,MAAAA,OAAO,EAAEC;AAFU,KAArB;AAID;;AAED,SAAOX,IAAP;AACD;;AAEDY,MAAM,CAACC,OAAP,GAAiBd,mBAAjB","sourcesContent":["const path = require('path');\n\n/**\n * @callback MatchObject\n * @param {string} [str]\n * @returns {boolean}\n */\n\nconst resolvedLoader = require.resolve('../../loader');\n\n/**\n * Injects refresh loader to all JavaScript-like and user-specified files.\n * @param {*} data Module factory creation data.\n * @param {MatchObject} matchObject A function to include/exclude files to be processed.\n * @returns {*} The injected module factory creation data.\n */\nfunction injectRefreshLoader(data, matchObject) {\n  if (\n    // Include and exclude user-specified files\n    matchObject(data.resource) &&\n    // Skip plugin's runtime utils to prevent self-referencing -\n    // this is useful when using the plugin as a direct dependency.\n    !data.resource.includes(path.join(__dirname, '../runtime/RefreshUtils')) &&\n    // Check to prevent double injection\n    !data.loaders.find(({ loader }) => loader === resolvedLoader)\n  ) {\n    // As we inject runtime code for each module,\n    // it is important to run the injected loader after everything.\n    // This way we can ensure that all code-processing have been done,\n    // and we won't risk breaking tools like Flow or ESLint.\n    data.loaders.unshift({\n      loader: resolvedLoader,\n      options: undefined,\n    });\n  }\n\n  return data;\n}\n\nmodule.exports = injectRefreshLoader;\n"]},"metadata":{},"sourceType":"script"}