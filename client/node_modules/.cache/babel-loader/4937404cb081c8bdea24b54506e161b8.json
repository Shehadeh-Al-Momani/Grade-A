{"ast":null,"code":"const validateOptions = require('schema-utils');\n\nconst {\n  DefinePlugin,\n  ModuleFilenameHelpers,\n  ProvidePlugin,\n  Template\n} = require('webpack');\n\nconst ConstDependency = require('webpack/lib/dependencies/ConstDependency');\n\nconst {\n  refreshGlobal,\n  webpackRequire,\n  webpackVersion\n} = require('./globals');\n\nconst {\n  createError,\n  getParserHelpers,\n  getRefreshGlobal,\n  getSocketIntegration,\n  injectRefreshEntry,\n  injectRefreshLoader,\n  normalizeOptions\n} = require('./utils');\n\nconst schema = require('./options.json'); // Mapping of react-refresh globals to Webpack runtime globals\n\n\nconst REPLACEMENTS = {\n  $RefreshRuntime$: {\n    expr: `${refreshGlobal}.runtime`,\n    req: [webpackRequire, `${refreshGlobal}.runtime`],\n    type: 'object'\n  },\n  $RefreshSetup$: {\n    expr: `${refreshGlobal}.setup`,\n    req: [webpackRequire, `${refreshGlobal}.setup`],\n    type: 'function'\n  },\n  $RefreshCleanup$: {\n    expr: `${refreshGlobal}.cleanup`,\n    req: [webpackRequire, `${refreshGlobal}.cleanup`],\n    type: 'function'\n  },\n  $RefreshReg$: {\n    expr: `${refreshGlobal}.register`,\n    req: [webpackRequire, `${refreshGlobal}.register`],\n    type: 'function'\n  },\n  $RefreshSig$: {\n    expr: `${refreshGlobal}.signature`,\n    req: [webpackRequire, `${refreshGlobal}.signature`],\n    type: 'function'\n  }\n};\n\nclass ReactRefreshPlugin {\n  /**\n   * @param {import('./types').ReactRefreshPluginOptions} [options] Options for react-refresh-plugin.\n   */\n  constructor(options = {}) {\n    validateOptions(schema, options, {\n      name: 'React Refresh Plugin',\n      baseDataPath: 'options'\n    });\n    /**\n     * @readonly\n     * @type {import('./types').NormalizedPluginOptions}\n     */\n\n    this.options = normalizeOptions(options);\n  }\n  /**\n   * Applies the plugin.\n   * @param {import('webpack').Compiler} compiler A webpack compiler object.\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    // Throw if we encounter an unsupported Webpack version,\n    // since things will most likely not work.\n    if (webpackVersion !== 4 && webpackVersion !== 5) {\n      throw createError(`Webpack v${webpackVersion} is not supported!`);\n    } // Skip processing in non-development mode, but allow manual force-enabling\n\n\n    if ( // Webpack do not set process.env.NODE_ENV, so we need to check for mode.\n    // Ref: https://github.com/webpack/webpack/issues/7074\n    (compiler.options.mode !== 'development' || // We also check for production process.env.NODE_ENV,\n    // in case it was set and mode is non-development (e.g. 'none')\n    process.env.NODE_ENV && process.env.NODE_ENV === 'production') && !this.options.forceEnable) {\n      return;\n    } // Inject react-refresh context to all Webpack entry points\n\n\n    compiler.options.entry = injectRefreshEntry(compiler.options.entry, this.options); // Inject necessary modules to bundle's global scope\n\n    /** @type {Record<string, string>} */\n\n    let providedModules = {\n      __react_refresh_utils__: require.resolve('./runtime/RefreshUtils')\n    };\n\n    if (this.options.overlay === false) {\n      // Stub errorOverlay module so calls to it can be erased\n      const definePlugin = new DefinePlugin({\n        __react_refresh_error_overlay__: false,\n        __react_refresh_init_socket__: false\n      });\n      definePlugin.apply(compiler);\n    } else {\n      providedModules = { ...providedModules,\n        ...(this.options.overlay.module && {\n          __react_refresh_error_overlay__: require.resolve(this.options.overlay.module)\n        }),\n        ...(this.options.overlay.sockIntegration && {\n          __react_refresh_init_socket__: getSocketIntegration(this.options.overlay.sockIntegration)\n        })\n      };\n    }\n\n    const providePlugin = new ProvidePlugin(providedModules);\n    providePlugin.apply(compiler);\n    const matchObject = ModuleFilenameHelpers.matchObject.bind(undefined, this.options);\n    const {\n      evaluateToString,\n      toConstantDependency\n    } = getParserHelpers();\n    compiler.hooks.compilation.tap(this.constructor.name, (compilation, {\n      normalModuleFactory\n    }) => {\n      // Only hook into the current compiler\n      if (compilation.compiler !== compiler) {\n        return;\n      } // Set template for ConstDependency which is used by parser hooks\n\n\n      compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template()); // Tap into version-specific compilation hooks\n\n      switch (webpackVersion) {\n        case 4:\n          {\n            const outputOptions = compilation.mainTemplate.outputOptions;\n\n            compilation.mainTemplate.hooks.require.tap(this.constructor.name, // Constructs the module template for react-refresh\n            (source, chunk, hash) => {\n              // Check for the output filename\n              // This is to ensure we are processing a JS-related chunk\n              let filename = outputOptions.filename;\n\n              if (typeof filename === 'function') {\n                // Only usage of the `chunk` property is documented by Webpack.\n                // However, some internal Webpack plugins uses other properties,\n                // so we also pass them through to be on the safe side.\n                filename = filename({\n                  contentHashType: 'javascript',\n                  chunk,\n                  hash\n                });\n              } // Check whether the current compilation is outputting to JS,\n              // since other plugins can trigger compilations for other file types too.\n              // If we apply the transform to them, their compilation will break fatally.\n              // One prominent example of this is the HTMLWebpackPlugin.\n              // If filename is falsy, something is terribly wrong and there's nothing we can do.\n\n\n              if (!filename || !filename.includes('.js')) {\n                return source;\n              } // Split template source code into lines for easier processing\n\n\n              const lines = source.split('\\n'); // Webpack generates this line when the MainTemplate is called\n\n              const moduleInitializationLineNumber = lines.findIndex(line => line.includes('modules[moduleId].call(')); // Unable to find call to module execution -\n              // this happens if the current module does not call MainTemplate.\n              // In this case, we will return the original source and won't mess with it.\n\n              if (moduleInitializationLineNumber === -1) {\n                return source;\n              }\n\n              const moduleInterceptor = Template.asString([`${refreshGlobal}.init();`, 'try {', Template.indent(lines[moduleInitializationLineNumber]), '} finally {', Template.indent(`${refreshGlobal}.cleanup(moduleId);`), '}']);\n              return Template.asString([...lines.slice(0, moduleInitializationLineNumber), '', outputOptions.strictModuleExceptionHandling ? Template.indent(moduleInterceptor) : moduleInterceptor, '', ...lines.slice(moduleInitializationLineNumber + 1, lines.length)]);\n            });\n\n            compilation.mainTemplate.hooks.requireExtensions.tap(this.constructor.name, // Setup react-refresh globals as extensions to Webpack's require function\n            source => {\n              return Template.asString([source, '', getRefreshGlobal()]);\n            });\n            normalModuleFactory.hooks.afterResolve.tap(this.constructor.name, // Add react-refresh loader to process files that matches specified criteria\n            data => {\n              return injectRefreshLoader(data, matchObject);\n            });\n            compilation.hooks.normalModuleLoader.tap( // `Infinity` ensures this check will run only after all other taps\n            {\n              name: this.constructor.name,\n              stage: Infinity\n            }, // Check for existence of the HMR runtime -\n            // it is the foundation to this plugin working correctly\n            context => {\n              if (!context.hot) {\n                throw createError(['Hot Module Replacement (HMR) is not enabled!', 'React Refresh requires HMR to function properly.'].join(' '));\n              }\n            });\n            break;\n          }\n\n        case 5:\n          {\n            const NormalModule = require('webpack/lib/NormalModule');\n\n            const RuntimeGlobals = require('webpack/lib/RuntimeGlobals');\n\n            const ReactRefreshRuntimeModule = require('./runtime/RefreshRuntimeModule');\n\n            compilation.hooks.additionalTreeRuntimeRequirements.tap(this.constructor.name, // Setup react-refresh globals with a Webpack runtime module\n            (chunk, runtimeRequirements) => {\n              runtimeRequirements.add(RuntimeGlobals.interceptModuleExecution);\n              compilation.addRuntimeModule(chunk, new ReactRefreshRuntimeModule());\n            });\n            normalModuleFactory.hooks.afterResolve.tap(this.constructor.name, // Add react-refresh loader to process files that matches specified criteria\n            resolveData => {\n              injectRefreshLoader(resolveData.createData, matchObject);\n            });\n            NormalModule.getCompilationHooks(compilation).loader.tap( // `Infinity` ensures this check will run only after all other taps\n            {\n              name: this.constructor.name,\n              stage: Infinity\n            }, // Check for existence of the HMR runtime -\n            // it is the foundation to this plugin working correctly\n            context => {\n              if (!context.hot) {\n                throw createError(['Hot Module Replacement (HMR) is not enabled!', 'React Refresh requires HMR to function properly.'].join(' '));\n              }\n            });\n            break;\n          }\n\n        default:\n          {\n            throw createError(`Encountered unexpected Webpack version (v${webpackVersion})`);\n          }\n      }\n      /**\n       * Transform global calls into Webpack runtime calls.\n       * @param {*} parser\n       * @returns {void}\n       */\n\n\n      const parserHandler = parser => {\n        Object.entries(REPLACEMENTS).forEach(([key, info]) => {\n          parser.hooks.expression.for(key).tap(this.constructor.name, toConstantDependency(parser, info.expr, info.req));\n\n          if (info.type) {\n            parser.hooks.evaluateTypeof.for(key).tap(this.constructor.name, evaluateToString(info.type));\n          }\n        });\n      };\n\n      normalModuleFactory.hooks.parser.for('javascript/auto').tap(this.constructor.name, parserHandler);\n      normalModuleFactory.hooks.parser.for('javascript/dynamic').tap(this.constructor.name, parserHandler);\n      normalModuleFactory.hooks.parser.for('javascript/esm').tap(this.constructor.name, parserHandler);\n    });\n  }\n\n}\n\nmodule.exports.ReactRefreshPlugin = ReactRefreshPlugin;\nmodule.exports = ReactRefreshPlugin;","map":{"version":3,"sources":["E:/JCA/Projects/Project-5/Grade-A/Front-End/node_modules/@pmmmwh/react-refresh-webpack-plugin/lib/index.js"],"names":["validateOptions","require","DefinePlugin","ModuleFilenameHelpers","ProvidePlugin","Template","ConstDependency","refreshGlobal","webpackRequire","webpackVersion","createError","getParserHelpers","getRefreshGlobal","getSocketIntegration","injectRefreshEntry","injectRefreshLoader","normalizeOptions","schema","REPLACEMENTS","$RefreshRuntime$","expr","req","type","$RefreshSetup$","$RefreshCleanup$","$RefreshReg$","$RefreshSig$","ReactRefreshPlugin","constructor","options","name","baseDataPath","apply","compiler","mode","process","env","NODE_ENV","forceEnable","entry","providedModules","__react_refresh_utils__","resolve","overlay","definePlugin","__react_refresh_error_overlay__","__react_refresh_init_socket__","module","sockIntegration","providePlugin","matchObject","bind","undefined","evaluateToString","toConstantDependency","hooks","compilation","tap","normalModuleFactory","dependencyTemplates","set","outputOptions","mainTemplate","source","chunk","hash","filename","contentHashType","includes","lines","split","moduleInitializationLineNumber","findIndex","line","moduleInterceptor","asString","indent","slice","strictModuleExceptionHandling","length","requireExtensions","afterResolve","data","normalModuleLoader","stage","Infinity","context","hot","join","NormalModule","RuntimeGlobals","ReactRefreshRuntimeModule","additionalTreeRuntimeRequirements","runtimeRequirements","add","interceptModuleExecution","addRuntimeModule","resolveData","createData","getCompilationHooks","loader","parserHandler","parser","Object","entries","forEach","key","info","expression","for","evaluateTypeof","exports"],"mappings":"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","sourcesContent":["const validateOptions = require('schema-utils');\nconst { DefinePlugin, ModuleFilenameHelpers, ProvidePlugin, Template } = require('webpack');\nconst ConstDependency = require('webpack/lib/dependencies/ConstDependency');\nconst { refreshGlobal, webpackRequire, webpackVersion } = require('./globals');\nconst {\n  createError,\n  getParserHelpers,\n  getRefreshGlobal,\n  getSocketIntegration,\n  injectRefreshEntry,\n  injectRefreshLoader,\n  normalizeOptions,\n} = require('./utils');\nconst schema = require('./options.json');\n\n// Mapping of react-refresh globals to Webpack runtime globals\nconst REPLACEMENTS = {\n  $RefreshRuntime$: {\n    expr: `${refreshGlobal}.runtime`,\n    req: [webpackRequire, `${refreshGlobal}.runtime`],\n    type: 'object',\n  },\n  $RefreshSetup$: {\n    expr: `${refreshGlobal}.setup`,\n    req: [webpackRequire, `${refreshGlobal}.setup`],\n    type: 'function',\n  },\n  $RefreshCleanup$: {\n    expr: `${refreshGlobal}.cleanup`,\n    req: [webpackRequire, `${refreshGlobal}.cleanup`],\n    type: 'function',\n  },\n  $RefreshReg$: {\n    expr: `${refreshGlobal}.register`,\n    req: [webpackRequire, `${refreshGlobal}.register`],\n    type: 'function',\n  },\n  $RefreshSig$: {\n    expr: `${refreshGlobal}.signature`,\n    req: [webpackRequire, `${refreshGlobal}.signature`],\n    type: 'function',\n  },\n};\n\nclass ReactRefreshPlugin {\n  /**\n   * @param {import('./types').ReactRefreshPluginOptions} [options] Options for react-refresh-plugin.\n   */\n  constructor(options = {}) {\n    validateOptions(schema, options, {\n      name: 'React Refresh Plugin',\n      baseDataPath: 'options',\n    });\n\n    /**\n     * @readonly\n     * @type {import('./types').NormalizedPluginOptions}\n     */\n    this.options = normalizeOptions(options);\n  }\n\n  /**\n   * Applies the plugin.\n   * @param {import('webpack').Compiler} compiler A webpack compiler object.\n   * @returns {void}\n   */\n  apply(compiler) {\n    // Throw if we encounter an unsupported Webpack version,\n    // since things will most likely not work.\n    if (webpackVersion !== 4 && webpackVersion !== 5) {\n      throw createError(`Webpack v${webpackVersion} is not supported!`);\n    }\n\n    // Skip processing in non-development mode, but allow manual force-enabling\n    if (\n      // Webpack do not set process.env.NODE_ENV, so we need to check for mode.\n      // Ref: https://github.com/webpack/webpack/issues/7074\n      (compiler.options.mode !== 'development' ||\n        // We also check for production process.env.NODE_ENV,\n        // in case it was set and mode is non-development (e.g. 'none')\n        (process.env.NODE_ENV && process.env.NODE_ENV === 'production')) &&\n      !this.options.forceEnable\n    ) {\n      return;\n    }\n\n    // Inject react-refresh context to all Webpack entry points\n    compiler.options.entry = injectRefreshEntry(compiler.options.entry, this.options);\n\n    // Inject necessary modules to bundle's global scope\n    /** @type {Record<string, string>} */\n    let providedModules = {\n      __react_refresh_utils__: require.resolve('./runtime/RefreshUtils'),\n    };\n\n    if (this.options.overlay === false) {\n      // Stub errorOverlay module so calls to it can be erased\n      const definePlugin = new DefinePlugin({\n        __react_refresh_error_overlay__: false,\n        __react_refresh_init_socket__: false,\n      });\n      definePlugin.apply(compiler);\n    } else {\n      providedModules = {\n        ...providedModules,\n        ...(this.options.overlay.module && {\n          __react_refresh_error_overlay__: require.resolve(this.options.overlay.module),\n        }),\n        ...(this.options.overlay.sockIntegration && {\n          __react_refresh_init_socket__: getSocketIntegration(this.options.overlay.sockIntegration),\n        }),\n      };\n    }\n\n    const providePlugin = new ProvidePlugin(providedModules);\n    providePlugin.apply(compiler);\n\n    const matchObject = ModuleFilenameHelpers.matchObject.bind(undefined, this.options);\n    const { evaluateToString, toConstantDependency } = getParserHelpers();\n    compiler.hooks.compilation.tap(\n      this.constructor.name,\n      (compilation, { normalModuleFactory }) => {\n        // Only hook into the current compiler\n        if (compilation.compiler !== compiler) {\n          return;\n        }\n\n        // Set template for ConstDependency which is used by parser hooks\n        compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());\n\n        // Tap into version-specific compilation hooks\n        switch (webpackVersion) {\n          case 4: {\n            const outputOptions = compilation.mainTemplate.outputOptions;\n            compilation.mainTemplate.hooks.require.tap(\n              this.constructor.name,\n              // Constructs the module template for react-refresh\n              (source, chunk, hash) => {\n                // Check for the output filename\n                // This is to ensure we are processing a JS-related chunk\n                let filename = outputOptions.filename;\n                if (typeof filename === 'function') {\n                  // Only usage of the `chunk` property is documented by Webpack.\n                  // However, some internal Webpack plugins uses other properties,\n                  // so we also pass them through to be on the safe side.\n                  filename = filename({\n                    contentHashType: 'javascript',\n                    chunk,\n                    hash,\n                  });\n                }\n\n                // Check whether the current compilation is outputting to JS,\n                // since other plugins can trigger compilations for other file types too.\n                // If we apply the transform to them, their compilation will break fatally.\n                // One prominent example of this is the HTMLWebpackPlugin.\n                // If filename is falsy, something is terribly wrong and there's nothing we can do.\n                if (!filename || !filename.includes('.js')) {\n                  return source;\n                }\n\n                // Split template source code into lines for easier processing\n                const lines = source.split('\\n');\n                // Webpack generates this line when the MainTemplate is called\n                const moduleInitializationLineNumber = lines.findIndex((line) =>\n                  line.includes('modules[moduleId].call(')\n                );\n                // Unable to find call to module execution -\n                // this happens if the current module does not call MainTemplate.\n                // In this case, we will return the original source and won't mess with it.\n                if (moduleInitializationLineNumber === -1) {\n                  return source;\n                }\n\n                const moduleInterceptor = Template.asString([\n                  `${refreshGlobal}.init();`,\n                  'try {',\n                  Template.indent(lines[moduleInitializationLineNumber]),\n                  '} finally {',\n                  Template.indent(`${refreshGlobal}.cleanup(moduleId);`),\n                  '}',\n                ]);\n\n                return Template.asString([\n                  ...lines.slice(0, moduleInitializationLineNumber),\n                  '',\n                  outputOptions.strictModuleExceptionHandling\n                    ? Template.indent(moduleInterceptor)\n                    : moduleInterceptor,\n                  '',\n                  ...lines.slice(moduleInitializationLineNumber + 1, lines.length),\n                ]);\n              }\n            );\n\n            compilation.mainTemplate.hooks.requireExtensions.tap(\n              this.constructor.name,\n              // Setup react-refresh globals as extensions to Webpack's require function\n              (source) => {\n                return Template.asString([source, '', getRefreshGlobal()]);\n              }\n            );\n\n            normalModuleFactory.hooks.afterResolve.tap(\n              this.constructor.name,\n              // Add react-refresh loader to process files that matches specified criteria\n              (data) => {\n                return injectRefreshLoader(data, matchObject);\n              }\n            );\n\n            compilation.hooks.normalModuleLoader.tap(\n              // `Infinity` ensures this check will run only after all other taps\n              { name: this.constructor.name, stage: Infinity },\n              // Check for existence of the HMR runtime -\n              // it is the foundation to this plugin working correctly\n              (context) => {\n                if (!context.hot) {\n                  throw createError(\n                    [\n                      'Hot Module Replacement (HMR) is not enabled!',\n                      'React Refresh requires HMR to function properly.',\n                    ].join(' ')\n                  );\n                }\n              }\n            );\n\n            break;\n          }\n          case 5: {\n            const NormalModule = require('webpack/lib/NormalModule');\n            const RuntimeGlobals = require('webpack/lib/RuntimeGlobals');\n            const ReactRefreshRuntimeModule = require('./runtime/RefreshRuntimeModule');\n\n            compilation.hooks.additionalTreeRuntimeRequirements.tap(\n              this.constructor.name,\n              // Setup react-refresh globals with a Webpack runtime module\n              (chunk, runtimeRequirements) => {\n                runtimeRequirements.add(RuntimeGlobals.interceptModuleExecution);\n                compilation.addRuntimeModule(chunk, new ReactRefreshRuntimeModule());\n              }\n            );\n\n            normalModuleFactory.hooks.afterResolve.tap(\n              this.constructor.name,\n              // Add react-refresh loader to process files that matches specified criteria\n              (resolveData) => {\n                injectRefreshLoader(resolveData.createData, matchObject);\n              }\n            );\n\n            NormalModule.getCompilationHooks(compilation).loader.tap(\n              // `Infinity` ensures this check will run only after all other taps\n              { name: this.constructor.name, stage: Infinity },\n              // Check for existence of the HMR runtime -\n              // it is the foundation to this plugin working correctly\n              (context) => {\n                if (!context.hot) {\n                  throw createError(\n                    [\n                      'Hot Module Replacement (HMR) is not enabled!',\n                      'React Refresh requires HMR to function properly.',\n                    ].join(' ')\n                  );\n                }\n              }\n            );\n\n            break;\n          }\n          default: {\n            throw createError(`Encountered unexpected Webpack version (v${webpackVersion})`);\n          }\n        }\n\n        /**\n         * Transform global calls into Webpack runtime calls.\n         * @param {*} parser\n         * @returns {void}\n         */\n        const parserHandler = (parser) => {\n          Object.entries(REPLACEMENTS).forEach(([key, info]) => {\n            parser.hooks.expression\n              .for(key)\n              .tap(this.constructor.name, toConstantDependency(parser, info.expr, info.req));\n\n            if (info.type) {\n              parser.hooks.evaluateTypeof\n                .for(key)\n                .tap(this.constructor.name, evaluateToString(info.type));\n            }\n          });\n        };\n\n        normalModuleFactory.hooks.parser\n          .for('javascript/auto')\n          .tap(this.constructor.name, parserHandler);\n        normalModuleFactory.hooks.parser\n          .for('javascript/dynamic')\n          .tap(this.constructor.name, parserHandler);\n        normalModuleFactory.hooks.parser\n          .for('javascript/esm')\n          .tap(this.constructor.name, parserHandler);\n      }\n    );\n  }\n}\n\nmodule.exports.ReactRefreshPlugin = ReactRefreshPlugin;\nmodule.exports = ReactRefreshPlugin;\n"]},"metadata":{},"sourceType":"script"}